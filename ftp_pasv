package main

import (
	"fmt"
	"io"
	"log"
	"net"
	"strconv"
	"time"
	//"runtime"
	"os"
	"strings"
	"bufio"
	//"regexp"
)

var ftp_conn net.Conn

//var data_conn net.Conn

var data_listener net.Listener

var err error

/*
var user_name = "admin"
var user_passwd = "zhongxing"
var	ftp_addr ="192.168.1.5:21"
*/
/*
var user_name = "anonymous"
var user_passwd = "kevin@gmail.com"
var ftp_addr = "ftp.freebsd.org:21"
*/
/*
var user_name = "anonymous"
var user_passwd = "kevin@gmail.com"
var ftp_addr = "127.0.0.1:21"
*/

/*
var user_name = "anonymous"
var user_passwd = "kevin@gmail.com"
var	ftp_addr ="10.80.77.151:7021"
*/

var user_name = "anonymous"
var user_passwd = "kevin@gmail.com"
var ftp_addr = "10.80.222.35:36"

type ftp_server struct {
	ip_port string //"10.80.222.35:36"
	name    string //"anonymous"
	passwd  string //"kevin@gmail.com"
}

/*
var user_name = "anonymous"
var user_passwd = "kevin@gmail.com"
var	ftp_addr ="10.80.85.162:21"
*/

func time_test() {
	t := time.Now()
	fmt.Println(t)
	fmt.Println(t)
	fmt.Println("%d\n", t.Year())
}

/*
func isTimeout(err error) bool {
	e, ok := err.(error)
	return ok && e.Timeout()
}
*/

func ftpcmd_noblocked(cmd string, result []uint8, sock net.Conn) {

	//send cmd
	cmd += "\r\n"
	send_buf := []byte(cmd)
	buf_len := 0

	//fmt.Println("%s\n",send_buf)
	//sock.SetDeadline(time.Now().Add(1000 * time.Millisecond))
	send_len, err := sock.Write(send_buf)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("send:%d,%s", send_len, send_buf[:])

	//loop read the result of cmd
	for {
		read_len, err := sock.Read(result[buf_len:])
		if err != nil {
			/*
				if err.Timeout() {
					log.Printf("RECV time out")
					break
				}
			*/
			log.Printf("read error")
			//log.Fatal(err)
			break
		}
		if read_len == 0 {
			log.Printf("read len is 0")
			break
		}
		log.Printf("RECV:read_len %d,%s", read_len, result[buf_len:read_len])
		buf_len += read_len
	}
	//log.Printf("RECV:%d,%q",read_len,result[:])
	log.Printf("RECV:%d,%s", buf_len, result[:buf_len])
}

func ftpcmd(cmd string, result []uint8, sock net.Conn) {

	//send cmd
	cmd += "\r\n"
	send_buf := []byte(cmd)
	buf_len := 0

	send_len, err := sock.Write(send_buf)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("send:%d,%s", send_len, send_buf[:])

	//loop read the result of cmd
	read_len, err := sock.Read(result[buf_len:])
	if err != nil {
		log.Printf("read error")
	}
	if read_len == 0 {
		log.Printf("read len is 0")
	}
	buf_len += read_len
	log.Printf("RECV:%d,%s", buf_len, result[:buf_len])
}

func init_data_port(data_port string) {

	data_listener, err = net.Listen("tcp", data_port)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf(" data port listen OK")
}

func data_connect() net.Conn {
	var data_conn net.Conn

	data_conn, err = data_listener.Accept()
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("data connect OK")

	return data_conn

}

func port_trans_file(file_name string, data_conn net.Conn) {

	trans_file(file_name, data_conn)
}

func trans_file(file_name string, data_conn net.Conn) {

	var file_len int64

	read_buf := make([]uint8, 4096)

	//data_conn.SetDeadline(time.Now().Add(1000 * time.Millisecond))

	write_file, write_err := os.OpenFile(file_name, os.O_WRONLY|os.O_CREATE, 0666)

	if write_err != nil {
		log.Fatal(write_err)
	}

	defer data_conn.Close()
	defer write_file.Close()

	file_len = 0
	for {
		read_len, err := data_conn.Read(read_buf[:])
		if err == io.EOF {
			//log.Printf("RECV end")
			break
		} else if err != nil {
			log.Fatal(err)
		}

		//log.Printf("RECV:%d,%s", read_len, read_buf[:read_len])
		write2file(read_buf, read_len, write_file)
		file_len += int64(read_len)

		//log.Printf("recv :%d write:%d", read_len, start)
	}

	log.Printf("download :%s :%d", file_name, file_len)

	return
}

func pasv_trans_file(ip_port string, file_name string) {

	var file_len int64
	var data_conn net.Conn

	read_buf := make([]uint8, 4096)

	data_conn, err = net.Dial("tcp", ip_port)
	if err != nil {
		log.Fatal(err)
	}

	//data_conn.SetDeadline(time.Now().Add(1000 * time.Millisecond))

	defer data_conn.Close()

	write_file, write_err := os.OpenFile(file_name, os.O_WRONLY|os.O_CREATE, 0666)

	if write_err != nil {
		log.Fatal(write_err)
	}

	defer write_file.Close()

	file_len = 0
	for {
		read_len, err := data_conn.Read(read_buf[:])
		if err == io.EOF {
			//log.Printf("RECV end")
			break
		} else if err != nil {
			log.Fatal(err)
		}

		//log.Printf("RECV:%d,%s", read_len, read_buf[:read_len])
		write2file(read_buf, read_len, write_file)
		file_len += int64(read_len)

		//log.Printf("recv :%d write:%d", read_len, start)
	}

	log.Printf("download :%s :%d", file_name, file_len)

	return
}

func write2file(buf []byte, length int, file *os.File) {
	//loop write file
	start := 0
	for {
		write_len, write_err := file.Write(buf[start:length])

		if write_err != nil {
			log.Fatal(write_err)
		}

		start += write_len
		if start >= length {
			break
		}
	}
	return

}


//func get_server_list() ftp_server {
func main() {

    server_list:=make([]ftp_server,60,200)
	
	//var server ftp_server 

				
    ini_file, err := os.Open("server.ini")

	if err != nil {
		log.Fatal(err)
	}
	
	//defer ini_file.Close()
	
	bio_reader:=bufio.NewReader(ini_file)
	
    line:=0	
	//loop read file
	for {
		
		buf,is_prefix,err := bio_reader.ReadLine()
		
		if err == io.EOF {
			log.Printf("read end")
			break
		} else if err != nil {
			log.Fatal(err)
		}
		
		if is_prefix{
			log.Printf("read is too long")
			break	
		}
		
		log.Printf("read buf:%s",buf)
		
		//fmt.Sscanf(string(buf), "%s %s %s",&server.ip_port, &server.name,&server.passwd)	
		//fmt.Println("%d  %s  %s  %s",line,server.ip_port,server.name,server.passwd)
		

				
		fmt.Sscanf(string(buf), "%s %s %s", &server_list[line].ip_port, &server_list[line].name, &server_list[line].passwd)	
		log.Println(line,server_list[line].ip_port,server_list[line].name,server_list[line].passwd)
		
		line+=1
		
		if line >= 200 {
			log.Printf("line is beyond 200")
			break	
		}
	}
	
	/*
	for i,v:=range server_list{
		fmt.Println(i,v)
	}
	*/
	
	
	return

}


func main_logtest() {
	logfile, err := os.OpenFile("test.log", os.O_RDWR|os.O_CREATE, 0)
	if err != nil {
		fmt.Printf("%s\r\n", err.Error())
		os.Exit(-1)
	}
	defer logfile.Close()
	logger := log.New(logfile, "\r\n", log.Ldate|log.Ltime|log.Llongfile)
	logger.Println("hello")
	logger.Println("oh....")
	logger.Fatal("test")
	logger.Fatal("test2")
}

/*get the data ip and port from the recv buf*/
func get_ip_port_v1(recv_buf []uint8) string {
	var port_high int
	var port_low int
	var ip [4]int

	//raw_buf:=recv_buf[27:]

	//log.Printf("raw_buf:%s",raw_buf)

	/*
	   ip_buf:=strings.Split(string(raw_buf),",")
	   log.Printf("ip_buf:%s %s %s %s %s %s",ip_buf[0],ip_buf[1],ip_buf[2],ip_buf[3],ip_buf[4],ip_buf[5])
	*/

	/*227 Entering Passive Mode (10,80,222,35,216,4).*/
	fmt.Sscanf(string(recv_buf), "*(%d,%d,%d,%d,%d,%d)*", &ip[0], &ip[1], &ip[2], &ip[3], &port_high, &port_low)

	//fmt.sprintf(recv_buf,"*(%d,%d,%d,%d,%d,%d)*",&ip[0],&ip[1],&ip[2],&ip[3],&port_high,&port_low)

	//port_high,_=strconv.Atoi(ip_buf[4])
	//port_low,_=strconv.Atoi(ip_buf[5])

	log.Printf("ip:%d %d %d %d port_high:%d port_low:%d", ip[0], ip[1], ip[2], ip[3], port_high, port_low)

	port := port_high*256 + port_low
	log.Printf("port:%d", port)

	ip_port := strconv.Itoa(ip[0]) + "." + strconv.Itoa(ip[1]) + "." + strconv.Itoa(ip[2]) + "." + strconv.Itoa(ip[3]) + ":" + strconv.Itoa(port)
	log.Printf("ip_port:%s", ip_port)
	return ip_port
}

/*get the data ip and port from the recv buf*/
func get_ip_port(recv_buf string) string {
	var port [2]int
	var ip [4]int

	//log.Printf("recv_buf:%s",recv_buf)

	ip_buf1 := strings.Split(recv_buf, ")")
	ip_buf2 := strings.Split(ip_buf1[0], "(")
	//fmt.Printf("%v\n",ip_buf2)
	//log.Printf("ip_buf2[1]:%s",ip_buf2[1])

	/*227 Entering Passive Mode (10,80,222,35,216,4).*/
	fmt.Sscanf(ip_buf2[1], "%d,%d,%d,%d,%d,%d", &ip[0], &ip[1], &ip[2], &ip[3], &port[0], &port[1])

	//fmt.Sprintf(ip_port,"%d.%d.%d.%d:%d",ip[0],ip[1],ip[2],ip[3],port[0]*0XFF+port[1])
	ip_port := strconv.Itoa(ip[0]) + "." + strconv.Itoa(ip[1]) + "." + strconv.Itoa(ip[2]) + "." + strconv.Itoa(ip[3]) + ":" + strconv.Itoa(port[0]*256+port[1])
	log.Printf("ip port:%s", ip_port)
	return ip_port
}



func port_ftp(ftp_server) {

	//var data_port string
	var data_conn net.Conn

	data := make([]uint8, 4096)
	read_buf := make([]uint8, 4096)

	ftp_conn, err = net.Dial("tcp", ftp_addr)
	if err != nil {
		log.Fatal(err)
	}

	defer ftp_conn.Close()

	log.Println("Connect Server: " + ftp_server.ip_port + " OK")

	/* need loop for read sock buf */
	read_len, err := ftp_conn.Read(data[:])
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Server Response:%d,%s", read_len, data[:read_len])

	ftpcmd("USER "+ftp_server.name, read_buf, ftp_conn)

	ftpcmd("PASS "+ftp_server.passwd, read_buf, ftp_conn)

	ftpcmd("SYST ", read_buf, ftp_conn)

	ftpcmd("TYPE I", read_buf, ftp_conn)

	//port download

	init_data_port(":50156")

	ftpcmd("PORT 10,80,85,140,195,236", read_buf, ftp_conn)

	data_conn = data_connect()

	ftpcmd("RETR TortoiseSVN-1.7.6.22632-win32-svn-1.7.4.msi", read_buf, ftp_conn)

	port_trans_file("TortoiseSVN-1.7.6.22632-win32-svn-1.7.4.msi", data_conn)

	//NLIST
	/* list dir
	ftpcmd("PASV ", read_buf, ftp_conn)

	data_port = get_ip_port(string(read_buf))

	ftpcmd("CWD pub/FreeBSD", read_buf, ftp_conn)

	ftpcmd("NLST", read_buf, ftp_conn)

	pasv_trans_file(data_port, "TortoiseSVN-1.7.6.22632-win32-svn-1.7.4.msi")
	*/

	//download README.TXT
	/*
		ftpcmd("PASV ", read_buf, ftp_conn)

		data_port = get_ip_port(string(read_buf))

		ftpcmd("RETR jdk-6u13-windows-i586-p.exe", read_buf, ftp_conn)

		pasv_trans_file(data_port, "jdk-6u13-windows-i586-p.exe")
	*/
	//ftpcmd("TYPE A",read_buf,ftp_conn)

	//ftpcmd("LIST /",read_buf,ftp_conn)
	//ftpcmd("PWD ",read_buf,ftp_conn)
	//ftpcmd("XPWD ", read_buf, ftp_conn)

	ftpcmd("QUIT", read_buf, ftp_conn)
}
